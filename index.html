<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable.min.css"
    />
    <title>요세푸스 시뮬레이터</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: "Pretendard Variable", Pretendard, -apple-system,
                BlinkMacSystemFont, system-ui, Roboto, "Helvetica Neue",
                "Segoe UI", "Apple SD Gothic Neo", "Noto Sans KR",
                "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji",
                "Segoe UI Symbol", sans-serif;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse {
            animation: pulse 2s infinite;
        }

        /* 현재 카운팅 중인 사람 하이라이트 */
        .person-current-step > div:first-child {
            background: #1d3fff !important;
            color: #ffffff !important;
            box-shadow:
                0 0 0 3px rgba(255, 255, 255, 0.95),
                0 0 12px rgba(29, 63, 255, 0.8);
        }

        /* 제거 직전 빨간색 하이라이트 */
        .person-eliminating > div:first-child {
            background: #ef4444 !important;
            color: #ffffff !important;
            box-shadow: 0 0 16px rgba(239, 68, 68, 1);
            transform: scale(1.25);
            transition: all 0.3s ease;
        }

        @keyframes arrowMove {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .arrow-anim {
            animation: arrowMove 0.6s ease-in-out;
        }
    </style>
</head>

<body class="bg-gradient-to-br from-[#8B9FFF] via-[#7B8FFF] to-[#9B8FFF]">
    <div class="flex flex-col items-center justify-center p-1 sm:p-4 min-h-screen">

        <!-- 제목 -->
        <h1 class="text-2xl sm:text-4xl md:text-5xl font-bold text-white mb-3 sm:mb-4 drop-shadow-lg text-center px-4">
            요세푸스 시뮬레이터
        </h1>

        <!-- 입력 카드 -->
        <div
            class="backdrop-blur-lg rounded-xl p-3 sm:p-4 mb-0 sm:mb-4 shadow-2xl w-full max-w-md"
            style="background: rgba(255, 255, 255, 0.25); padding:0.75rem 1.5rem;"
        >
            <div class="flex flex-row flex-wrap gap-2 sm:gap-6 mb-2 sm:mb-1">
                <!-- N -->
                <div class="flex-1 min-w-[140px]">
                    <label class="text-white text-sm mb-1 block font-semibold drop-shadow">사람 수 (N)</label>
                    <input
                        id="nInput"
                        type="number"
                        min="3"
                        max="30"
                        value="15"
                        class="px-3 py-2 rounded-lg bg-white text-[#1d3fff] border-2 border-white/50 w-full text-sm font-semibold shadow-md"
                    />
                </div>
                <!-- K -->
                <div class="flex-1 min-w-[140px]">
                    <label class="text-white text-sm mb-1 block font-semibold drop-shadow">제거 간격 (K)</label>
                    <input
                        id="kInput"
                        type="number"
                        min="1"
                        max="10"
                        value="4"
                        class="px-3 py-2 rounded-lg bg-white text-[#1d3fff] border-2 border-white/50 w-full text-sm font-semibold shadow-md"
                    />
                </div>
            </div>

            <!-- 최대 인원 안내 문구 -->
            <p class="text-[11px] sm:text-xs text-white drop-shadow text-left mt-1 font-medium">
                (※ N = <span class="font-bold">최대 30명</span>, K = <span class="font-bold">최대 10간격</span> 가능)
            </p>
        </div>

        <!-- 원형 시각화 -->
        <div class="relative w-full max-w-sm sm:max-w-xl aspect-square mb-0 sm:mb-4">
            <div class="absolute inset-0 flex items-center justify-center">

                <!-- 점선 원 -->
                <svg class="absolute inset-0" width="100%" height="100%" viewBox="0 0 600 600">
                    <circle
                        cx="300"
                        cy="300"
                        r="200"
                        fill="none"
                        stroke="rgba(255,255,255,0.4)"
                        stroke-dasharray="5,5"
                        stroke-width="3"
                    />
                </svg>

                <!-- 사람들 -->
                <div id="peopleContainer" class="absolute inset-0 z-10"></div>

                <!-- 화살표 -->
                <svg
                    id="arrowContainer"
                    class="absolute inset-0 z-20"
                    width="100%"
                    height="100%"
                    viewBox="0 0 600 600"
                ></svg>

                <!-- 중앙 컨트롤 -->
                <div
                    id="centerControl"
                    class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-30 w-[40%] max-w-[200px] sm:w-[40%] sm:max-w-xs"
                >
                </div>
            </div>
        </div>

        <!-- 제거 순서 -->
        <div class="mt-1 sm:mt-3 bg-white/20 backdrop-blur-lg rounded-2xl p-2 sm:p-4 text-white w-full max-w-4xl shadow-xl border border-white/30">
            <p class="text-sm sm:text-lg font-bold mb-2 text-center drop-shadow">제거 순서</p>
            <div
                id="eliminationOrder"
                class="flex flex-wrap items-center justify-center gap-1 sm:gap-2 text-xs sm:text-base max-h-24 sm:max-h-32 overflow-y-auto"
            >
                <span class="text-white drop-shadow">자동 시작를 눌러주세요</span>
            </div>
        </div>
    </div>

    <script>
        const RADIUS = 200;

        let n = 15;
        let k = 4;
        let eliminated = [];
        let survivor = null;

        let remaining = [];
        let currentIndex = 0;
        let isRunningAuto = false;
        let isAnimatingStep = false;

        const nInput = document.getElementById("nInput");
        const kInput = document.getElementById("kInput");
        const peopleContainer = document.getElementById("peopleContainer");
        const arrowContainer = document.getElementById("arrowContainer");
        const centerControl = document.getElementById("centerControl");
        const eliminationOrder = document.getElementById("eliminationOrder");

        let delCountSpan = null;
        let leftCountSpan = null;

        function getPosition(index, total) {
            const angle = (index * 2 * Math.PI) / total - Math.PI / 2;
            return {
                x: RADIUS * Math.cos(angle),
                y: RADIUS * Math.sin(angle),
                angle,
            };
        }

        function setCurrentStep(personIndex) {
            const all = peopleContainer.querySelectorAll("[data-person]");
            all.forEach((el) => el.classList.remove("person-current-step"));
            if (personIndex === null || personIndex === undefined) return;
            const target = peopleContainer.querySelector(
                `[data-person="${personIndex}"]`
            );
            if (target) target.classList.add("person-current-step");
        }

        function drawArrow(fromIdx, toIdx) {
            arrowContainer.innerHTML = "";

            const fp = getPosition(fromIdx, n);
            const tp = getPosition(toIdx,   n);

            const sx = 300 + fp.x;
            const sy = 300 + fp.y;
            const ex = 300 + tp.x;
            const ey = 300 + tp.y;

            let diff = tp.angle - fp.angle;
            if (diff < 0) diff += 2 * Math.PI;

            const arcRadius = RADIUS;
            const largeArc = diff > Math.PI ? 1 : 0;

            const defs   = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
            marker.setAttribute("id", "arrowhead");
            marker.setAttribute("markerWidth", "6");
            marker.setAttribute("markerHeight", "6");
            marker.setAttribute("refX", "5");
            marker.setAttribute("refY", "2.5");
            marker.setAttribute("orient", "auto");

            const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            poly.setAttribute("points", "0 0, 6 2.5, 0 5");
            poly.setAttribute("fill", "#FFD700");
            marker.appendChild(poly);

            defs.appendChild(marker);
            arrowContainer.appendChild(defs);

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute(
                "d",
                `M ${sx} ${sy} A ${arcRadius} ${arcRadius} 0 ${largeArc} 1 ${ex} ${ey}`
            );
            path.setAttribute("stroke", "#FFD700");
            path.setAttribute("stroke-width", "5");
            path.setAttribute("fill", "none");
            path.setAttribute("marker-end", "url(#arrowhead)");
            path.classList.add("arrow-anim");
            path.style.filter = "drop-shadow(0 2px 4px rgba(0,0,0,0.3))";

            arrowContainer.appendChild(path);
        }

        function clearArrow() {
            arrowContainer.innerHTML = "";
        }

        function renderPeople() {
            peopleContainer.innerHTML = "";

            for (let i = 0; i < n; i++) {
                const isDead   = eliminated.includes(i);
                const isWinner = survivor === i;

                const pos = getPosition(i, n);
                const leftPercent = ((300 + pos.x) / 600) * 100;
                const topPercent  = ((300 + pos.y) / 600) * 100;

                const item = document.createElement("div");
                item.dataset.person = i;
                item.className =
                    "absolute transition-all duration-500 " +
                    (isDead
                        ? "opacity-30 scale-75"
                        : isWinner
                        ? "scale-125"
                        : "scale-100");
                item.style.left = leftPercent + "%";
                item.style.top  = topPercent + "%";
                item.style.transform = "translate(-50%, -50%)";

                const circle = document.createElement("div");
                // 인원수에 따라 동적으로 크기 조정
                const sizeClass = n <= 12 
                    ? "w-11 h-11 sm:w-16 sm:h-16 text-base sm:text-xl"
                    : n <= 20
                    ? "w-9 h-9 sm:w-12 sm:h-12 text-sm sm:text-base"
                    : "w-8 h-8 sm:w-10 sm:h-10 text-xs sm:text-sm";
                
                circle.className =
                    "flex items-center justify-center rounded-full font-bold shadow-xl " +
                    sizeClass + " " +
                    (isDead
                        ? "bg-gray-400 text-gray-600"
                        : isWinner
                        ? "bg-gradient-to-br from-[#FFD700] to-[#FFA500] text-white animate-pulse"
                        : "bg-white text-[#1d3fff]");
                circle.textContent = i;
                item.appendChild(circle);

                if (isWinner) {
                    const badge = document.createElement("div");
                    badge.className =
                        "absolute -top-3 -right-3 bg-[#FFD700] text-[#111] text-xs font-bold px-2 py-1 rounded-full border-2 border-white shadow-xl";
                    badge.textContent = "생존";
                    item.appendChild(badge);
                }

                peopleContainer.appendChild(item);
            }
        }

        function updateEliminationOrder() {
            if (eliminated.length === 0) {
                eliminationOrder.innerHTML =
                    '<span class="text-white drop-shadow font-medium">자동시작을 눌러주세요</span>';
                return;
            }

            let html = "";
            eliminated.forEach((p, i) => {
                html += `<span class="text-red-200 font-bold drop-shadow">${p}번</span>`;
                if (i < eliminated.length - 1 || survivor !== null) {
                    html += `<span class="text-white drop-shadow">→</span>`;
                }
            });

            if (survivor !== null) {
                html += `<span class="text-yellow-200 font-bold text-base sm:text-xl drop-shadow-lg"> ${survivor}번 (생존자)</span>`;
            }

            eliminationOrder.innerHTML = html;
        }

        function setupCenterControl() {
            centerControl.innerHTML = `
              <div class="text-center bg-black/40 backdrop-blur-md rounded-2xl p-2 sm:p-4 border border-white/30 shadow-2xl">
                <div class="text-white text-lg sm:text-2xl font-bold mb-1 sm:mb-2 drop-shadow-lg">요세푸스</div>
                <div class="text-xs sm:text-sm mb-1 text-white drop-shadow font-medium">
                  제거: <span id="delCount" class="font-bold">0</span>명 ·
                  생존: <span id="leftCount" class="font-bold">${remaining.length}</span>명
                </div>
                <div class="flex flex-col gap-2 mt-2 justify-center">
                  <button
                    id="autoBtn"
                    class="flex-1 bg-gradient-to-r from-[#00C853] to-[#00E676] hover:from-[#00E676] hover:to-[#69F0AE]
                    text-white font-bold py-2 px-3 rounded-full shadow-lg text-xs sm:text-sm transform hover:scale-105 transition-all"
                  >
                    자동 시작
                  </button>
                  <button
                    id="stepBtn"
                    class="flex-1 bg-gradient-to-r from-[#2196F3] to-[#42A5F5] hover:from-[#42A5F5] hover:to-[#64B5F6]
                    text-white font-bold py-2 px-3 rounded-full shadow-lg text-xs sm:text-sm transform hover:scale-105 transition-all"
                  >
                    한단계
                  </button>
                </div>
              </div>
            `;

            delCountSpan  = document.getElementById("delCount");
            leftCountSpan = document.getElementById("leftCount");

            const autoBtn = document.getElementById("autoBtn");
            const stepBtn = document.getElementById("stepBtn");

            autoBtn.addEventListener("click", autoRun);
            stepBtn.addEventListener("click", stepRun);
        }

        function showFinalResult() {
            clearArrow();
            setCurrentStep(null);
            renderPeople();
            updateEliminationOrder();

            nInput.disabled = false;
            kInput.disabled = false;

            centerControl.innerHTML = `
              <div class="text-center bg-black/40 backdrop-blur-md rounded-2xl p-3 sm:p-4 border border-white/30 shadow-2xl">
                <div class="text-white text-xl sm:text-3xl font-bold mb-3 drop-shadow-lg"> 생존자: ${survivor}번</div>
                <button id="resetBtn"
                    class="bg-gradient-to-r from-[#6A52FF] to-[#904CFF] hover:from-[#904CFF] hover:to-[#B07FFF]
                    text-white font-bold py-2 px-5 sm:py-3 sm:px-6 rounded-full shadow-xl transform hover:scale-105 transition-all flex items-center gap-2 mx-auto text-sm sm:text-lg">
                     다시 하기
                </button>
              </div>
            `;
            document.getElementById("resetBtn").addEventListener("click", reset);
        }

        async function performOneElimination() {
            if (remaining.length <= 1) return;
            if (isAnimatingStep) return;
            isAnimatingStep = true;

            const startIndex = currentIndex;

            for (let step = 0; step < k; step++) {
                const len = remaining.length;
                const currentIdx = (startIndex + step) % len;
                const prevIdx    = (step === 0)
                    ? currentIdx
                    : (startIndex + step - 1 + len) % len;

                const currentPerson = remaining[currentIdx];
                const prevPerson    = remaining[prevIdx];

                setCurrentStep(currentPerson);

                if (step === 0) {
                    clearArrow();
                } else {
                    drawArrow(prevPerson, currentPerson);
                }

                await new Promise((res) => setTimeout(res, 300));
            }

            const elimIndex = (startIndex + k - 1) % remaining.length;
            const removed   = remaining[elimIndex];

            clearArrow();
            setCurrentStep(null);

            const targetEl = peopleContainer.querySelector(
                `[data-person="${removed}"]`
            );
            if (targetEl) {
                targetEl.classList.add("person-eliminating");
                await new Promise((res) => setTimeout(res, 300));
            }

            remaining.splice(elimIndex, 1);
            eliminated.push(removed);

            if (delCountSpan)  delCountSpan.textContent  = eliminated.length;
            if (leftCountSpan) leftCountSpan.textContent = remaining.length;

            renderPeople();
            updateEliminationOrder();

            if (remaining.length > 0) {
                currentIndex = elimIndex;
                if (currentIndex >= remaining.length) currentIndex = 0;
            }

            isAnimatingStep = false;

            if (remaining.length === 1) {
                survivor = remaining[0];
                showFinalResult();
            }
        }

        async function autoRun() {
            if (isRunningAuto || remaining.length <= 1) return;
            isRunningAuto = true;

            nInput.disabled = true;
            kInput.disabled = true;

            while (remaining.length > 1 && isRunningAuto) {
                await performOneElimination();
            }

            isRunningAuto = false;
        }

        function stepRun() {
            if (isRunningAuto || remaining.length <= 1) return;
            nInput.disabled = true;
            kInput.disabled = true;
            performOneElimination();
        }

        function reset() {
            n = Math.max(3, Math.min(30, n));

            eliminated = [];
            survivor = null;
            remaining = Array.from({ length: n }, (_, i) => i);
            currentIndex = 0;
            isRunningAuto = false;
            isAnimatingStep = false;

            nInput.value = n;
            nInput.disabled = false;
            kInput.disabled = false;
            clearArrow();
            setCurrentStep(null);

            renderPeople();
            updateEliminationOrder();
            setupCenterControl();
        }

        nInput.addEventListener("input", () => {
            n = Math.max(3, Math.min(30, parseInt(nInput.value) || 3));
            reset();
        });

        kInput.addEventListener("input", () => {
            k = Math.max(1, Math.min(10, parseInt(kInput.value) || 1));
        });

        window.addEventListener("resize", () => {
            renderPeople();
            clearArrow();
            setCurrentStep(null);
        });

        reset();
    </script>
</body>
</html>



